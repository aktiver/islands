<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Island-Based To-Do App</title>
  <!-- Load Material UI CSS (or your favorite CSS framework) -->
  <link rel="stylesheet" href="https://unpkg.com/@mui/material@latest/dist/material.min.css">
  
  <!-- Our custom styles for transitions and floating header -->
  <style>
    /* Floating Header */
    #floatingHeader {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      background-color: #1976d2; /* Material UI primary color */
      color: white;
      display: flex;
      align-items: center;
      padding: 0 1rem;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      z-index: 9999;
      justify-content: space-between;
    }
    #renderTime {
      font-weight: bold;
    }

    /* Add some space for the header */
    body {
      padding-top: 70px; 
      margin: 0;
      font-family: Roboto, sans-serif;
    }

    /* Card-like container for the Todo List */
    .todo-container {
      margin: 2rem auto;
      max-width: 600px;
      background: white;
      border-radius: 8px;
      padding: 1rem;
      box-shadow: 0 3px 6px rgba(0,0,0,0.1);
    }

    /* Simple animation for adding new tasks */
    .fade-in {
      animation: fadeIn 0.5s ease-in-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-5px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>

<body>
  <!-- Floating Header -->
  <div id="floatingHeader">
    <span>Todo App - Assigned to <span id="assignedUser"></span></span>
    <span id="renderTime">Last Render: 0ms</span>
  </div>

  <!-- Our Island for the Todo List -->
  <div data-island class="todo-container" id="todoIsland">
    <!-- We'll define the initial :state with an array of tasks + user info -->
    <div :state="{ 
      tasks: [],
      assignedUser: 'Jane Doe',
      lastRender: 0
    }">

      <h2>Todo List</h2>

      <!-- Add new task form -->
      <div style="margin-bottom:1rem;">
        <input
          type="text"
          placeholder="Task Title"
          :show="true"
          id="taskTitle"
          class="form-control"
          style="margin: 0.5rem 0;"
        />
        <textarea
          placeholder="Task Description"
          id="taskDesc"
          style="width:100%; margin-bottom:0.5rem;"
        ></textarea>

        <!-- Start and End dates -->
        <div style="display:flex; gap:1rem;">
          <input type="date" id="startDate" style="flex:1;" />
          <input type="date" id="endDate" style="flex:1;" />
        </div>

        <button 
          @click="addTask()" 
          class="mui-btn mui-btn--raised mui-btn--primary"
          style="margin-top:1rem;"
        >
          Add Task
        </button>
      </div>

      <!-- Render the tasks -->
      <div :html="renderTasks"></div>
    </div>
  </div>

  <!-- Load Lodash, Axios, and the island code (the code from your snippet) -->
  <script src="https://cdn.jsdelivr.net/npm/lodash@4/lodash.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

  <!-- Insert your big <script type="module"> snippet with islands, signals, etc. here -->
  <script type="module" src="./islands.js"></script>

  <!-- Next, define our custom logic for the to-do app -->
  <script type="module">
    import { islands } from './my-islands-code.js';
    import _ from 'lodash';

    // We can define custom code or methods by hooking into the island's signals or events.
    // The easiest approach: We'll define an "addTask()" function or similar inline in the code.

    // We can also augment the island by providing it with custom methods to call from @click="..."
    const todoRoot = document.getElementById('todoIsland');
    const todoIsland = islands.get(todoRoot);

    // We add a method "addTask()" to the island's signals, or we can do it dynamically as code strings.
    // Here, we do it imperatively for clarity:
    function addTaskMethod(signals, { $ev }) {
      const titleEl = document.getElementById('taskTitle');
      const descEl = document.getElementById('taskDesc');
      const startDate = document.getElementById('startDate').value;
      const endDate = document.getElementById('endDate').value;

      const newTask = {
        id: Date.now(),
        title: titleEl.value.trim() || 'Untitled',
        description: descEl.value.trim(),
        startDate,
        endDate,
        completed: false,
      };

      // We'll push it into signals.tasks (which is a Signal).
      signals.tasks.set((oldArr) => [...oldArr, newTask]);

      // Clear inputs
      titleEl.value = '';
      descEl.value = '';
      document.getElementById('startDate').value = '';
      document.getElementById('endDate').value = '';

      // Force a re-render so we can measure times, etc.
      updateRenderTime(signals);
    }

    // We'll define it as a code string so the user can do: @click="addTask()"
    // But let's just attach it to the island signals for convenience:
    todoIsland.signals.addTask = {
      set(fn) { /* No-op, just so it doesn't break. */ }
    };
    // We'll emulate the "call" style:
    todoIsland.signals.addTask.call = (signals, ev) => addTaskMethod(signals, ev);

    // We also define a "renderTasks" computed property in the island, for :html="renderTasks"
    todoIsland.signals.renderTasks = {
      val: '',
      deps: [],
      set() { /* no-op */ }
    };

    // We'll store our rendering logic in a function
    function getRenderTasksHTML(tasks) {
      if (!tasks || tasks.length === 0) {
        return '<p>No tasks yet.</p>';
      }
      // Build HTML for each task
      return tasks.map(task => {
        const daysLeft = computeDaysLeft(task.startDate, task.endDate);
        return `
          <div class="mui-panel fade-in" style="margin:0.5rem 0;">
            <h3>${_.escape(task.title)} ${task.completed ? '(Done)' : ''}</h3>
            <p>${_.escape(task.description)}</p>
            <p>Start: ${task.startDate || 'N/A'} | Due: ${task.endDate || 'N/A'}
              <br/>
              <em style="color:${daysLeft < 2 ? 'red' : 'inherit'}">
                ${daysLeft > 0 ? daysLeft + ' days left' : 'Due date passed'}
              </em>
            </p>
            <button
              class="mui-btn mui-btn--small mui-btn--accent"
              @click="toggleDone(${task.id})"
            >
              ${task.completed ? 'Mark Undone' : 'Mark Done'}
            </button>
            <button
              class="mui-btn mui-btn--small mui-btn--flat"
              @click="deleteTask(${task.id})"
            >
              Delete
            </button>
          </div>
        `;
      }).join('');
    }

    function computeDaysLeft(start, end) {
      if (!start || !end) return '??';
      const startTime = new Date(start).getTime();
      const endTime = new Date(end).getTime();
      const now = Date.now();

      // If already ended, show negative or 0
      if (now > endTime) return 0;

      // Compute difference in days
      const diff = endTime - now;
      return Math.ceil(diff / (1000 * 60 * 60 * 24));
    }

    // We'll define a "toggleDone" and "deleteTask" in a similar style
    function toggleDone(signals, { $ev }, id) {
      signals.tasks.set((oldArr) => {
        return oldArr.map(task => {
          if (task.id === id) {
            return { ...task, completed: !task.completed };
          }
          return task;
        });
      });
      updateRenderTime(signals);
    }

    function deleteTask(signals, { $ev }, id) {
      signals.tasks.set(oldArr => oldArr.filter(t => t.id !== id));
      updateRenderTime(signals);
    }

    // We'll store these methods so the island can call them from HTML (@click="toggleDone(123)")
    todoIsland.signals.toggleDone = { call: (signals, ev, id) => toggleDone(signals, ev, id) };
    todoIsland.signals.deleteTask = { call: (signals, ev, id) => deleteTask(signals, ev, id) };

    // Next, let's define a small reactivity for "renderTasks"
    // We'll manually add a dep so that any changes to tasks will update "renderTasks".
    // Then the island sees tasks changed => triggers deps => re-computes HTML => sets into val => :html="renderTasks" re-renders
    const oldGet = todoIsland.signals.renderTasks.get || (() => '');
    todoIsland.signals.renderTasks.get = () => {
      const tasksSignal = todoIsland.signals.tasks;
      if (tasksSignal) { 
        // register the dep
        tasksSignal.deps.push(() => {
          const newVal = getRenderTasksHTML(tasksSignal.val);
          todoIsland.signals.renderTasks.val = newVal;
          updateRenderTime(todoIsland.signals);
        });
        // Return initial HTML
        return getRenderTasksHTML(tasksSignal.val);
      }
      return oldGet();
    };

    // We'll set the initial val so that it's not empty
    todoIsland.signals.renderTasks.val = '<p>No tasks yet.</p>';

    // Also watch "assignedUser"
    // We'll set the floating header #assignedUser text
    const userSig = todoIsland.signals.assignedUser;
    if (userSig) {
      userSig.deps.push(() => {
        document.getElementById('assignedUser').textContent = userSig.val;
      });
      document.getElementById('assignedUser').textContent = userSig.val;
    }

    // Finally, track and display render times
    function updateRenderTime(signals) {
      const start = performance.now();
      // We'll do a quick re-bind or re-compute triggers
      // Typically, the framework calls the reactivity automatically.
      // We can measure the time after the next microtask:
      Promise.resolve().then(() => {
        const end = performance.now();
        const ms = Math.round(end - start);
        signals.lastRender.set(ms);
      });
    }

    // Listen for changes to lastRender
    if (todoIsland.signals.lastRender) {
      todoIsland.signals.lastRender.deps.push(() => {
        document.getElementById('renderTime').textContent = 'Last Render: ' + todoIsland.signals.lastRender.val + 'ms';
      });
    }

  </script>
</body>
</html>
